<!DOCTYPE html>
<html lang="zh-cn">
  <head>
  
  <link rel="stylesheet" href="/js/katex/katex.min.css" >
  <script src="/js/katex/katex.min.js" > </script>
  <script src="/js/katex/contrib/auto-render.min.js" ></script>
  <script>
      document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body);
      });
  </script>

  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="Jonathan Wang">
  
  
  
  <link rel="prev" href="https://GodLovesJonny.github.io/2020/numpy-allclose/" />
  <link rel="next" href="https://GodLovesJonny.github.io/2020/kliv/" />
  <link rel="canonical" href="https://GodLovesJonny.github.io/2020/se-notes/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           软件工程复习笔记 | Jonathan`s Blog
       
  </title>
  <meta name="title" content="软件工程复习笔记 | Jonathan`s Blog">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/GodLovesJonny.github.io"
    },
    "articleSection" : "posts",
    "name" : "软件工程复习笔记",
    "headline" : "软件工程复习笔记",
    "description" : "Software Process Software processes are the activities involved in producing a software system. General Software process models: The waterfall model, Incremental development, Reuse-oriented software engineering. Waterfall model phases: Requirements analysis and definition, System and software design, Implementation and unit testing, Integration and system testing, Operation and maintenance. The main drawback of the waterfall model: the difficulty of accommodating change after the process is underway. (In principle, a phase has to",
    "inLanguage" : "zh-cn",
    "author" : "Jonathan Wang",
    "creator" : "Jonathan Wang",
    "publisher": "Jonathan Wang",
    "accountablePerson" : "Jonathan Wang",
    "copyrightHolder" : "Jonathan Wang",
    "copyrightYear" : "2020",
    "datePublished": "2020-04-22 14:31:05 \x2b0800 CST",
    "dateModified" : "2020-04-22 14:31:05 \x2b0800 CST",
    "url" : "https:\/\/GodLovesJonny.github.io\/2020\/se-notes\/",
    "wordCount" : "2260",
    "keywords" : [ "software","notes", "Jonathan`s Blog"]
}
</script>

  
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    
        <div class="top-scroll-bar"></div>
    
    <div class="container">
        <div class="navbar-header header-logo">
            
            <span class="logo_mark" >></span>
            <a href="https://GodLovesJonny.github.io">
                <span class="logo_text" >$ cd /home/ </span>
                <span class="logo_cursor" ></span>
            </a>
            
        </div>
        <div class="navbar-right">
                
                <span class="menu">
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
                </span>
                <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-dark-mode"></i></a>
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     
         <div class="top-scroll-bar"></div>
     
     <div class="container">
        <div class="navbar-header">
            <div class="header-logo">
                
                    <span class="logo_mark">></span>
                    <a href="https://GodLovesJonny.github.io">
                        <span class="logo_text">$ cd /home/ </span>
                        <span class="logo_cursor"></span>
                </a>
                
            </div>
            <div class="navbar-right">
                <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-dark-mode"></i></a>
                <div class="menu-toggle">
                    <span></span><span></span><span></span>
                </div>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>

    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">软件工程复习笔记</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://GodLovesJonny.github.io" rel="author">Jonathan Wang</a> with ♥ 
                <span class="post-time">
                on <time datetime=2020-04-22 itemprop="datePublished">April 22, 2020</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="https://GodLovesJonny.github.io/categories/njtu-cst-learning-notes/"> NJTU CST Learning Notes </a>
                        
                </span>
                <span class="post-word-count">, 2260 words</span>
        </div>
    </header>
    <div class="post-content">
        

        

        
        
     
          
          
          

          
          
          

          <h1 id="software-process">Software Process</h1>
<ul>
<li><strong>Software processes</strong> are the activities involved in producing a software system.</li>
<li><strong>General Software process models</strong>: The waterfall model, Incremental development, Reuse-oriented software engineering.</li>
<li><strong>Waterfall model phases</strong>: Requirements analysis and definition, System and software design, Implementation and unit testing, Integration and system testing, Operation and maintenance.</li>
<li>The <strong>main drawback of the waterfall model</strong>: the difficulty of accommodating change after the process is underway. (In principle, a phase has to be complete before moving onto the next phase.)</li>
<li>The <strong>waterfall model</strong> is mostly used for <strong>large systems</strong>. (stable requirements, only appropriate when the requirements are well-understood and changes will be fairly limited during the design process)</li>
<li><strong>Incremental development benefits</strong>: 1. The <strong>cost of accommodating changing customer requirements</strong> is reduced; 2. It is <strong>easier to get customer feedback</strong> on the development work that has been done; 3. <strong>More rapid delivery and deployment</strong> of useful software to the customer is possible.</li>
<li><strong>Incremental development problems</strong>: 1. The <strong>process is not visible</strong> (lack of documents); 2. <strong>System structure tends to degrade</strong> as new increments are added.</li>
<li>Process stages of <strong>reuse-oriented software engineering</strong>: Requirements specification; Component analysis; Requirements modification; System design with reuse; Development and integration; System validation.</li>
<li><strong>Software specification</strong> is the process of establishing what <strong>services are required</strong> and <strong>the constraints</strong> on the system’s operation and development.</li>
<li><strong>Requirements engineering process</strong>: Feasibility study (Feasibility report); Requirements elicitation and analysis (System model); Requirements specification (User and system requirements); Requirements validation (Requirements document).</li>
<li>Requirement specification (<strong>what to do</strong>) / Software design (<strong>how to do</strong>)</li>
<li><strong>Design activities</strong>: Architectural design; Interface design; Component design; Database design.</li>
<li><strong>Software validation</strong>: <strong>Verification and validation (V &amp; V)</strong> is intended to show that a system conforms to its specification and meets the requirements of the system customer, which involves <strong>checking and review</strong> processes and <strong>system testing</strong> (most commonly used).</li>
<li><strong>Testing stages</strong>: Development or component testing (<strong>Individual components</strong> are tested independently); System testing (Testing of the system <strong>as a whole</strong>); Acceptance testing (Testing with customer data to check that the system <strong>meets the customer’s needs</strong>).</li>
<li><strong>Software evolution</strong>: Define system requirements; Assess existing systems; Propose system changes; Modify systems.</li>
<li><strong>Reducing the costs of rework</strong>: change <strong>avoidance</strong> (where the software process includes activities that can <strong>anticipate possible changes</strong> before significant rework is required; <strong>prototype system</strong>) and change <strong>tolerance</strong> (where the process is designed so that changes can be <strong>accommodated at relatively low cost</strong>; <strong>incremental development</strong>).</li>
<li><strong>A prototype</strong> is an initial version of a system used to demonstrate concepts and try out design options.</li>
<li>A prototype can be used in: <strong>The requirements engineering process</strong> to help with requirements elicitation and validation; <strong>In design processes</strong> to explore options and develop a UI design; <strong>In the testing process</strong> to run back-to-back tests.</li>
<li>Prototype development <strong>may involve leaving out functionality</strong>.</li>
<li><strong>Incremental development and delivery \(\downarrow\)</strong></li>
</ul>
<table>
<thead>
<tr>
<th>Incremental development</th>
<th>Incremental delivery</th>
</tr>
</thead>
<tbody>
<tr>
<td>Develop the system in increments and evaluate each increment before proceeding to the development of the next increment;</td>
<td>Deploy an increment for use by end-users;</td>
</tr>
<tr>
<td>Normal approach used in agile methods;</td>
<td>More realistic evaluation about practical use of software;</td>
</tr>
<tr>
<td>Evaluation done by user/customer proxy.</td>
<td>Difficult to implement for replacement systems as increments have less functionality than the system being replaced.</td>
</tr>
<tr>
<td>Deliver after finishing.</td>
<td>Deliver every increment.</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Incremental delivery pros and cons \(\downarrow\)</strong></li>
</ul>
<table>
<thead>
<tr>
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr>
<td>Customer value can be delivered with each increment so <strong>system functionality is available earlier</strong>.</td>
<td>Most systems <strong>require a set of basic facilities that are used by different parts of the system.</strong></td>
</tr>
<tr>
<td><strong>Early increments act as a prototype</strong> to help elicit requirements for later increments.</td>
<td>The essence of <strong>iterative processes</strong> is that the specification is developed in conjunction with the software.</td>
</tr>
<tr>
<td>Lower risk of <strong>overall project failure</strong>.</td>
<td>&mdash;</td>
</tr>
<tr>
<td><strong>The highest priority system services</strong> tend to receive the most testing.</td>
<td>&mdash;</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Incremental delivery</strong> combines advantages of <strong>waterfall model</strong> and <strong>incremental development</strong>, which can deal with software changes well.</li>
<li><strong>Boehm’s spiral model</strong>: 1. Process is represented as a <strong>spiral</strong> rather than as a sequence of activities with backtracking; 2. <strong>Each loop</strong> in the spiral represents <strong>a phase in the process</strong>; 3. No fixed phases such as specification or design - <strong>loops in the spiral are chosen depending on what is required</strong>; 4. <strong>Risks are explicitly assessed and resolved</strong> throughout the process.</li>
<li><strong>Spiral model sectors</strong>: Objective setting; Risk assessment and reduction; Development and validation; Planning (for the next phase).</li>
<li><strong>The Rational Unified Process (RUP)</strong> is a modern generic process derived from the work on the UML and associated process, bringing together aspects of the 3 generic process models discussed previously.</li>
<li>RUP is organized into phases (inception, elaboration, construction and transition) but separates activities (requirements, analysis and design, etc.) from these phases.</li>
<li><strong>RUP phases\(\downarrow\)</strong></li>
</ul>
<table>
<thead>
<tr>
<th>Phase</th>
<th>Activities</th>
</tr>
</thead>
<tbody>
<tr>
<td>Inception</td>
<td>Establish the business case for the system.</td>
</tr>
<tr>
<td>Elaboration</td>
<td>Develop an understanding of the problem domain and the system architecture.</td>
</tr>
<tr>
<td>Construction</td>
<td>System design, programming and testing.</td>
</tr>
<tr>
<td>Transition</td>
<td>Deploy the system in its operating environment.</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>RUP good practice\(\downarrow\)</strong></li>
</ul>
<table>
<thead>
<tr>
<th>Item</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td>Develop software <strong>iteratively</strong></td>
<td>Plan increments based on customer priorities and deliver highest priority increments first.</td>
</tr>
<tr>
<td>Manage requirements</td>
<td>Explicitly document customer requirements and keep track of changes to these requirements.</td>
</tr>
<tr>
<td>Use component-based architectures</td>
<td>Organize the system architecture as a set of reusable components.</td>
</tr>
<tr>
<td>Visually model software</td>
<td>Use <strong>graphical UML models</strong> to present static and dynamic views of the software.</td>
</tr>
<tr>
<td>Verify software quality</td>
<td>Ensure that the software meet’s organizational quality standards.</td>
</tr>
<tr>
<td>Control changes to software</td>
<td>Manage software changes using a change management system and configuration management tools.</td>
</tr>
</tbody>
</table>
<h1 id="agile-software-development">Agile Software Development</h1>
<h2 id="agile-methods">Agile Methods</h2>
<p>Features:</p>
<ul>
<li><strong>Focus on the code</strong> rather than the design.</li>
<li>Are <strong>based on an iterative approach</strong> to software development.</li>
<li>Are intended to <strong>deliver working software quickly and evolve this quickly</strong> to meet changing requirements.</li>
</ul>
<p>The <strong>aim of agile methods</strong> is to <strong>reduce overheads in the software process</strong> (e.g. by limiting documentation) and to be able to <strong>respond quickly to changing requirements without excessive rework</strong>.</p>
<h3 id="the-principles-of-agile-methods">The principles of agile methods</h3>
<table>
<thead>
<tr>
<th>Principle</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Customer involvement</td>
<td>Customers should be closely involved throughout the development process. Their role is provide and prioritize new system requirements and to evaluate the iterations of the system.</td>
</tr>
<tr>
<td>Incremental delivery</td>
<td>The software is developed in increments with the customer specifying the requirements to be included in each increment.</td>
</tr>
<tr>
<td>People not process</td>
<td>The skills of the development team should be recognized and exploited. Team members should be left to develop their own ways of working without prescriptive processes.</td>
</tr>
<tr>
<td>Embrace change</td>
<td>Expect the system requirements to change and so design the system to accommodate these changes.</td>
</tr>
<tr>
<td>Maintain simplicity</td>
<td>Focus on simplicity in both the software being developed and in the development process. Wherever possible, actively work to eliminate complexity from the system.</td>
</tr>
</tbody>
</table>
<h3 id="agile-method-applicability">Agile method applicability</h3>
<ul>
<li><strong>small or medium-sized product</strong></li>
<li>Custom system development within an organization, where there is a clear commitment from the <strong>customer to become involved in the development process</strong> and where there are not a lot of external rules and regulations that affect the software.</li>
<li>Because of their focus on small, tightly-integrated teams, there are <strong>problems in scaling agile methods to large systems</strong>.</li>
</ul>
<h3 id="two-key-issues">Two key issues</h3>
<ul>
<li>Are systems that are developed using an agile approach <strong>maintainable</strong>, given the emphasis in the development process of <strong>minimizing formal documentation</strong>?</li>
<li>Can agile methods be used effectively for <strong>evolving a system in response to customer change requests</strong>?</li>
</ul>
<p>Problems may arise if <strong>original development team cannot be maintained</strong>.</p>
<h3 id="plan-driven-and-agile-development">Plan-driven and agile development</h3>
<h4 id="plan-driven-development">Plan-driven development</h4>
<ul>
<li>A plan-driven approach to software engineering is <strong>based around separate development stages</strong> with the outputs to be produced at each of these stages planned in advance.</li>
<li>Not necessarily waterfall model – plan-driven, <strong>incremental development is possible (delivered as a whole).</strong></li>
<li>Iteration occurs within activities.</li>
</ul>
<h4 id="agile-development">Agile development</h4>
<ul>
<li><strong>Specification, design, implementation and testing are inter-leaved and the outputs</strong> from the development process are decided through a process of negotiation during the software development process.</li>
<li>Agile methods rely on <strong>good tools</strong> to keep track of an evolving design.</li>
</ul>
<h2 id="extreme-programming-xp">Extreme Programming (XP)</h2>
<p>Perhaps the best-known and most widely used agile method.</p>
<p>Extreme Programming (XP) takes an <strong>‘extreme’ approach</strong> to iterative development:</p>
<ul>
<li>New versions may be built several times per day;</li>
<li>Increments are delivered to customers every 2 weeks;</li>
<li>All tests must be run for every build and the build is only accepted if tests run successfull.</li>
</ul>
<p>User requirements are expressed as <strong>scenarios</strong> or <strong>user stories</strong>, which are later broke into <strong>implementation tasks</strong>.</p>
<h3 id="xp-practices">XP practices</h3>
<table>
<thead>
<tr>
<th>Principle or practive</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Incremental planning</td>
<td>Requirements are recorded on story cards and the stories to be included in a release are determined by the time available and their relative priority. The developers break these stories into development ‘Tasks’.</td>
</tr>
<tr>
<td>Small releases</td>
<td>The minimal useful set of functionality that provides business value is developed first. Releases of the system are frequent and incrementally add functionality to the first release.</td>
</tr>
<tr>
<td>Simple design</td>
<td>Enough design is carried out to meet the current requirements and no more.</td>
</tr>
<tr>
<td>Test-first development</td>
<td>An <strong>automated unit test framework</strong> is used to write tests for a new piece of functionality before that functionality itself is implemented.</td>
</tr>
<tr>
<td>Refactoring</td>
<td>All developers are expected to refactor the code continuously as soon as possible code improvements are found. This keeps the code simple and maintainable. This <strong>improves the understandability</strong> of the software and so reduces the need for documentation. <strong>Changes are easier to make</strong> because the code is well-structured and clear. However, some changes requires architecture refactoring and this is much more expensive.</td>
</tr>
<tr>
<td>Pair programming</td>
<td>Developers work in pairs, checking each other’s work and providing the support to always do a good job.</td>
</tr>
<tr>
<td>Collective ownership</td>
<td>The pairs of developers work on all areas of the system, so that no islands of expertise develop and all the developers take responsibility for all of the code. Anyone can change anything.</td>
</tr>
<tr>
<td>Continuous integration</td>
<td>As soon as the work on a task is complete, it is integrated into the whole system. After any such integration, all the unit tests in the system must pass.</td>
</tr>
<tr>
<td>Sustainable pace</td>
<td>Large amounts of overtime are not considered acceptable as the net effect is often to reduce code quality and medium term productivity.</td>
</tr>
<tr>
<td>On-site customer</td>
<td>A representative of the end-user of the system (the customer) should be available full time for the use of the XP team. In an extreme programming process, the customer is a member of the development team and is responsible for bringing system requirements to the team for implementation.</td>
</tr>
</tbody>
</table>
<h2 id="scrum">Scrum</h2>
<p>The Scrum approach is a <strong>general agile method</strong> but its focus is on <strong>managing iterative development</strong> rather than specific agile practices.</p>
<h3 id="three-phases-in-scrum">Three phases in Scrum:</h3>
<ul>
<li>The <strong>initial phase</strong> is an outline planning phase where you establish the general objectives for the project and design the software architecture.</li>
<li>This is followed by a series of <strong>sprint cycles</strong> (<strong>Assess, Select, Review, Develop</strong>), where each cycle develops <strong>an increment</strong> of the system.</li>
<li>The <strong>project closure phase</strong> wraps up the project, completes required documentation such as system help frames and user manuals and assesses the lessons learned from the project.</li>
</ul>
<h3 id="the-sprint-cycle">The Sprint cycle</h3>
<p><strong>Sprints are fixed length, normally 2–4 weeks.</strong> They correspond to <strong>the development of a release</strong> of the system in XP.</p>
<p>The starting point for planning is the product backlog, which is the list of work to be done on the project.</p>
<p>The <strong>selection phase</strong> involves all of the project team who work with the customer to select the features and functionality to be developed during the sprint.</p>
<p>Once these are agreed, the team organize themselves to <strong>develop</strong> the software. <strong>During this stage the team is isolated from the customer and the organization, with all communications channelled through the so-called ‘Scrum master’.</strong></p>
<p>The role of the Scrum master is to <strong>protect the development team from external distractions</strong>.</p>
<p>At the end of the sprint, the work done is <strong>reviewed and presented to stakeholders</strong>. The next sprint cycle then begins.</p>
<h3 id="scrum-benefits">Scrum benefits</h3>
<ul>
<li>The product is <strong>broken down into a set of manageable and understandable chunks</strong>.</li>
<li>Unstable requirements do not hold up progress.</li>
<li>The whole team have visibility of everything and consequently team communication is improved.</li>
<li>Customers see on-time delivery of increments and gain feedback on how the product works.</li>
<li>Trust between customers and developers is established and a positive culture is created in which everyone expects the project to succeed.</li>
</ul>
<h2 id="scaling-agile-methods">Scaling Agile Methods</h2>
<p>Agile methods have proved to be successful for small and medium sized projects that can be developed by a small co-located team. It is sometimes argued that the success of these methods comes because of improved communications which is possible when everyone is working together.</p>
<p><strong>Scaling up agile methods</strong> involves changing these to cope with larger, longer projects where there are multiple development teams, perhaps working in different locations.</p>
<h3 id="scaling-out-and-scaling-up">Scaling out and scaling up</h3>
<ul>
<li><strong>‘Scaling up’</strong> is concerned with using agile methods for developing large software systems that cannot be developed by a small team.</li>
<li><strong>‘Scaling out’</strong> is concerned with how agile methods can be introduced across a large organization with many years of software development experience.</li>
</ul>
<p>When scaling agile methods, it is essential to maintain <strong>agile fundamentals</strong>:</p>
<ul>
<li>Flexible planning</li>
<li>frequent system releases</li>
<li>continuous integration</li>
<li>test-driven development</li>
<li>good team communications.</li>
</ul>
<p>For large systems development, it is not possible to focus only on the code of the system. You need to do more <strong>up-front design and system documentation</strong>. <strong>Cross-team communication mechanisms have to be designed and used.</strong></p>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>Jonathan Wang </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://GodLovesJonny.github.io/2020/se-notes/>https://GodLovesJonny.github.io/2020/se-notes/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://GodLovesJonny.github.io/tags/software/">
                    #software</a></span>
            
            <span class="tag"><a href="https://GodLovesJonny.github.io/tags/notes/">
                    #notes</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://GodLovesJonny.github.io">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://GodLovesJonny.github.io/2020/numpy-allclose/" class="prev" rel="prev" title="Numpy散记 -- allclose函数的使用"><i class="iconfont icon-left"></i>&nbsp;Numpy散记 -- allclose函数的使用</a>
         
        
        <a href="https://GodLovesJonny.github.io/2020/kliv/" class="next" rel="next" title="[KLI] Klingon Vocabulary">[KLI] Klingon Vocabulary&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
    <h5 id="wc" style="font-size: 1rem;text-align: center;">2300 Words|Read in about 5 Min|本文总阅读量<span id="busuanzi_value_page_pv"></span>次</h5>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2020 - 2020</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://GodLovesJonny.github.io">Jonathan Wang</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
          <span id="busuanzi_container_site_pv">
              本站访问量：<span id="busuanzi_value_site_pv"></span>次
          </span>
    </div>
</footer>













    
    
    <script src="/js/vendor_no_gallery.min.js" async=""></script>
    
  






     </div>
  </body>
</html>
