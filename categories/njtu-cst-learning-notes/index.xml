<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>NJTU CST Learning Notes on Jonathan`s Blog</title>
    <link>https://GodLovesJonny.github.io/categories/njtu-cst-learning-notes/</link>
    <description>Recent content in NJTU CST Learning Notes on Jonathan`s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>All rights reserved - 2020</copyright>
    <lastBuildDate>Fri, 24 Apr 2020 13:43:03 +0800</lastBuildDate>
    
	<atom:link href="https://GodLovesJonny.github.io/categories/njtu-cst-learning-notes/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>软件工程复习笔记[7] - Software Testing</title>
      <link>https://GodLovesJonny.github.io/2020/se-notes7/</link>
      <pubDate>Fri, 24 Apr 2020 13:43:03 +0800</pubDate>
      
      <guid>https://GodLovesJonny.github.io/2020/se-notes7/</guid>
      <description>Program Testing Goals To demonstrate to the developer and the customer that the software meets its requirements. (leads to validation testing) To discover situations in which the behavior of the software is incorrect, undesirable or does not conform to its specification. (leads to defect testing) Verification vs Validation Verification &amp;ldquo;Are we building the product right”. The software should conform to its specification. Validation &amp;ldquo;Are</description>
    </item>
    
    <item>
      <title>软件工程复习笔记[6] - Design And Implementation</title>
      <link>https://GodLovesJonny.github.io/2020/se-notes6/</link>
      <pubDate>Thu, 23 Apr 2020 19:09:46 +0800</pubDate>
      
      <guid>https://GodLovesJonny.github.io/2020/se-notes6/</guid>
      <description>Software design and implementation activities are invariably inter-leaved. An Object-oriented Design Process Object-oriented design processes involve developing a number of different system models. They require a lot of effort for development and maintenance of these models and, for small systems, this may not be cost-effective. However, for large systems developed by different groups design models are an important communication mechanism. Common activities Define the context and modes of use of</description>
    </item>
    
    <item>
      <title>软件工程复习笔记[5] - Architectural Design</title>
      <link>https://GodLovesJonny.github.io/2020/se-notes5/</link>
      <pubDate>Thu, 23 Apr 2020 13:47:30 +0800</pubDate>
      
      <guid>https://GodLovesJonny.github.io/2020/se-notes5/</guid>
      <description>The design process for identifying the sub-systems making up a system and the framework for sub-system control and communication is architectural design, which is an early stage of the system design process. The output of this design process is a description of the software architecture. It represents the link between specification and design processes and is often carried out in parallel with some specification activities. Each architectural model only shows</description>
    </item>
    
    <item>
      <title>软件工程复习笔记[4] - System Modeling</title>
      <link>https://GodLovesJonny.github.io/2020/se-notes4/</link>
      <pubDate>Thu, 23 Apr 2020 09:53:53 +0800</pubDate>
      
      <guid>https://GodLovesJonny.github.io/2020/se-notes4/</guid>
      <description>System modeling is the process of developing abstract models of a system, with each model presenting a different view or perspective of that system. System modeling helps the analyst to understand the functionality of the system and models are used to communicate with customers. Unified Modeling Language (UML) The UML is the standard language for visualizing, specifying, constructing, and documenting the artifacts of a software-intensive system. It can be used</description>
    </item>
    
    <item>
      <title>软件工程复习笔记[3] - Requirements Engineering</title>
      <link>https://GodLovesJonny.github.io/2020/se-notes3/</link>
      <pubDate>Wed, 22 Apr 2020 17:24:10 +0800</pubDate>
      
      <guid>https://GodLovesJonny.github.io/2020/se-notes3/</guid>
      <description>Types Of Requirement User requirements: Statements in natural language plus diagrams of the services the system provides and its operational constraints. Written for customers. System requirements: A structured document setting out detailed descriptions of the system’s functions, services and operational constraints. Defines what should be implemented so may be part of a contract between client and contractor. Functional And Non-functional Requirements Functional requirements</description>
    </item>
    
    <item>
      <title>软件工程复习笔记[2] - Agile Software Development</title>
      <link>https://GodLovesJonny.github.io/2020/se-notes2/</link>
      <pubDate>Wed, 22 Apr 2020 17:18:47 +0800</pubDate>
      
      <guid>https://GodLovesJonny.github.io/2020/se-notes2/</guid>
      <description>Agile Methods Features Focus on the code rather than the design. Are based on an iterative approach to software development. Are intended to deliver working software quickly and evolve this quickly to meet changing requirements. The aim of agile methods is to reduce overheads in the software process (e.g. by limiting documentation) and to be able to respond quickly to changing requirements without excessive rework. The principles of agile methods</description>
    </item>
    
    <item>
      <title>软件工程复习笔记[1] - Software Process</title>
      <link>https://GodLovesJonny.github.io/2020/se-notes1/</link>
      <pubDate>Wed, 22 Apr 2020 14:31:05 +0800</pubDate>
      
      <guid>https://GodLovesJonny.github.io/2020/se-notes1/</guid>
      <description>Software Process Software processes are the activities involved in producing a software system. General Software process models: The waterfall model, Incremental development, Reuse-oriented software engineering. Waterfall model phases: Requirements analysis and definition, System and software design, Implementation and unit testing, Integration and system testing, Operation and maintenance. The main drawback of the waterfall model: the difficulty of accommodating change after the process is underway. (In principle, a phase has to</description>
    </item>
    
  </channel>
</rss>